)
}
# Wrap the custom function with safely
safe_study_download <- safely(study_download)
bla <- deployments_filtered[1,] |>
bla <- deployments_filtered[1,] |>
select(all_of(col_deploy)) |>
group_split(study_id) |>
map(~{
study_id <- unique(.x$study_id)
individuals <- unique(.x$individual_local_identifier)
res <- safe_study_download(study_id, c(653, 2299894820), individuals)
if(!is.null(res$result)){
study_file <- here("Data", "Studies", str_c(study_id, "_study.csv"))
tibble(res$result) |>
write_csv(study_name)
tibble(study_id = study_id, file = study_file)
} else {
tibble(study_id = study_id, error_text = paste(res$error, collapse = " "))
}
},
.progess = T
) |>
bind_rows()
View(bla)
bla <- deployments_filtered |>
filter(study_id == study_id[1])
bla <- deployments_filtered |>
filter(study_id == study_id[1])
study_id <- unique(bla$study_id)
sensor_type_id <- c(653, 2299894820)
individual_local_identifier <- unique(bla$individual_local_identifier)
trial <- movebank_download_study(
study_id,
sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
remove_movebank_outliers = T,
omit_derived_data = T,
convert_spatial_columns = F,
atributes = NULL
)
trial <- movebank_download_study(
study_id,
sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
# remove_movebank_outliers = T,
# omit_derived_data = T,
# convert_spatial_columns = F,
# atributes = NULL
)
trial <- movebank_download_study(
study_id,
# sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
# remove_movebank_outliers = T,
# omit_derived_data = T,
# convert_spatial_columns = F,
# atributes = NULL
)
trial <- movebank_download_study(
study_id
# sensor_type_id = sensor_type_id,
#individual_local_identifier = individual_local_identifier,
# remove_movebank_outliers = T,
# omit_derived_data = T,
# convert_spatial_columns = F,
# atributes = NULL
)
typeof(individual_local_identifier)
View(bla)
individual_local_identifier <- unique |>
as.character()
individual_local_identifier <- unique(bla$individual_local_identifier) |>
as.character()
trial <- movebank_download_study(
study_id
sensor_type_id = sensor_type_id,
trial <- movebank_download_study(
study_id,
sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
remove_movebank_outliers = T,
omit_derived_data = T,
convert_spatial_columns = F,
atributes = NULL
)
trial <- movebank_download_study(
study_id,
#sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
remove_movebank_outliers = T,
omit_derived_data = T,
convert_spatial_columns = F,
atributes = NULL
)
individual_local_identifier <- unique(bla$individual_local_identifier) |>
as.character()
trial <- movebank_download_study(
study_id,
#sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
remove_movebank_outliers = T,
omit_derived_data = T,
convert_spatial_columns = F,
atributes = NULL
)
trial <- movebank_download_study(
study_id,
sensor_type_id = sensor_type_id,
#individual_local_identifier = individual_local_identifier,
remove_movebank_outliers = T,
omit_derived_data = T,
convert_spatial_columns = F,
atributes = NULL
)
trial <- movebank_download_study(
study_id,
#sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
remove_movebank_outliers = T,
omit_derived_data = T,
convert_spatial_columns = F,
atributes = NULL
)
trial <- movebank_download_study(
study_id,
#sensor_type_id = sensor_type_id,
#individual_local_identifier = individual_local_identifier,
remove_movebank_outliers = T,
omit_derived_data = T,
convert_spatial_columns = F,
atributes = NULL
)
trial <- movebank_download_study(
study_id,
sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier
)
trial <- movebank_download_study(
study_id,
sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier
atributes = NULL
trial <- movebank_download_study(
study_id,
sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
atributes = NULL
)
# Define a custom function to handle multiple arguments
study_download <- function(
study_id, sensor_type_id, individual_local_identifier
) {
movebank_retrieve(
study_id,
sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
remove_movebank_outliers = T,
omit_derived_data = T,
convert_spatial_columns = F,
atributes = NULL
)
}
# Wrap the custom function with safely
safe_study_download <- safely(study_download)
bla <- deployments_filtered[1,] |>
select(all_of(col_deploy)) |>
group_split(study_id) |>
map(~{
study_id <- unique(.x$study_id)
individuals <- unique(.x$individual_local_identifier) |>
as.character()
res <- safe_study_download(study_id, c(653, 2299894820), individuals)
if(!is.null(res$result)){
study_file <- here("Data", "Studies", str_c(study_id, "_study.csv"))
tibble(res$result) |>
write_csv(study_name)
tibble(study_id = study_id, file = study_file)
} else {
tibble(study_id = study_id, error_text = paste(res$error, collapse = " "))
}
},
.progess = T
) |>
bind_rows()
View(bla)
col_deploy <- c("taxon_canonical_name", "study_id", "deployment_id" ,
"sensor_type_ids",
"individual_local_identifier", "individual_number_of_deployments",
"deployment_local_identifier", "tag_local_identifier",
"sex", "animal_life_stage",  "manipulation_type", "error_text"
)
# Define a custom function to handle multiple arguments
study_download <- function(
study_id, sensor_type_id, individual_local_identifier
) {
movebank_retrieve(
entity_type = "event",
study_id,
sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
remove_movebank_outliers = T,
omit_derived_data = T,
convert_spatial_columns = F,
atributes = NULL
)
}
# Wrap the custom function with safely
safe_study_download <- safely(study_download)
bla <- deployments_filtered[1,] |>
select(all_of(col_deploy)) |>
group_split(study_id) |>
map(~{
study_id <- unique(.x$study_id)
individuals <- unique(.x$individual_local_identifier) |>
as.character()
res <- safe_study_download(study_id, c(653, 2299894820), individuals)
if(!is.null(res$result)){
study_file <- here("Data", "Studies", str_c(study_id, "_study.csv"))
tibble(res$result) |>
write_csv(study_name)
tibble(study_id = study_id, file = study_file)
} else {
tibble(study_id = study_id, error_text = paste(res$error, collapse = " "))
}
},
.progess = T
) |>
bind_rows()
View(bla)
# Define a custom function to handle multiple arguments
study_download <- function(
study_id, sensor_type_id, individual_local_identifier
) {
movebank_retrieve(
entity_type = "event",
study_id,
sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
remove_movebank_outliers = T,
omit_derived_data = T,
convert_spatial_columns = F,
atributes = NULL
)
}
# Wrap the custom function with safely
safe_study_download <- safely(study_download)
bla <- deployments_filtered[1,] |>
select(all_of(col_deploy)) |>
group_split(study_id) |>
map(~{
study_id <- unique(.x$study_id)
individuals <- unique(.x$individual_local_identifier) |>
as.character()
res <- safe_study_download(
entity_type = "event", study_id, c(653, 2299894820), individuals)
if(!is.null(res$result)){
study_file <- here("Data", "Studies", str_c(study_id, "_study.csv"))
tibble(res$result) |>
write_csv(study_name)
tibble(study_id = study_id, file = study_file)
} else {
tibble(study_id = study_id, error_text = paste(res$error, collapse = " "))
}
},
.progess = T
) |>
bind_rows()
View(bla)
# Define a custom function to handle multiple arguments
study_download <- function(
study_id, sensor_type_id, individual_local_identifier
) {
movebank_retrieve(
entity_type = "event",
study_id,
sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
remove_movebank_outliers = T,
omit_derived_data = T,
convert_spatial_columns = F,
atributes = NULL
)
}
# Wrap the custom function with safely
safe_study_download <- safely(study_download)
bla <- deployments_filtered[1,] |>
select(all_of(col_deploy)) |>
group_split(study_id) |>
map(~{
study_id <- unique(.x$study_id)
individuals <- unique(.x$individual_local_identifier) |>
as.character()
res <- safe_study_download(
entity_type = "event", study_id, c(653, 2299894820), individuals)
if(!is.null(res$result)){
study_file <- here("Data", "Studies", str_c(study_id, "_study.csv"))
tibble(res$result) |>
write_csv(study_name)
tibble(study_id = study_id, file = study_file)
} else {
tibble(study_id = study_id, error_text = paste(res$error, collapse = " "))
}
},
.progess = T
) |>
bind_rows()
View(bla)
movebank_retrieve(
entity_type = "event",
study_id,
sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
remove_movebank_outliers = T,
omit_derived_data = T,
convert_spatial_columns = F,
atributes = NULL
)
# Define a custom function to handle multiple arguments
study_download <- function(
study_id, sensor_type_id, individual_local_identifier
) {
movebank_retrieve(
entity_type = "event",
study_id,
sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
remove_movebank_outliers = T,
omit_derived_data = T,
convert_spatial_columns = F,
atributes = NULL
)
}
# Wrap the custom function with safely
safe_study_download <- safely(study_download)
bla <- deployments_filtered[1,] |>
select(all_of(col_deploy)) |>
group_split(study_id) |>
map(~{
study_id <- unique(.x$study_id)
individuals <- unique(.x$individual_local_identifier) |>
as.character()
res <- safe_study_download(study_id, c(653, 2299894820), individuals)
if(!is.null(res$result)){
study_file <- here("Data", "Studies", str_c(study_id, "_study.csv"))
tibble(res$result) |>
write_csv(study_name)
tibble(study_id = study_id, file = study_file)
} else {
tibble(study_id = study_id, error_text = paste(res$error, collapse = " "))
}
},
.progess = T
) |>
bind_rows()
View(bla)
col_deploy <- c("taxon_canonical_name", "study_id", "deployment_id" ,
"sensor_type_ids",
"individual_local_identifier", "individual_number_of_deployments",
"deployment_local_identifier", "tag_local_identifier",
"sex", "animal_life_stage",  "manipulation_type", "error_text"
)
# Define a custom function to handle multiple arguments
study_download <- function(
study_id, sensor_type_id, individual_local_identifier
) {
movebank_download_study(
study_id,
sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
# remove_movebank_outliers = T,
# omit_derived_data = T,
# convert_spatial_columns = F,
# atributes = NULL
)
}
# Wrap the custom function with safely
safe_study_download <- safely(study_download)
bla <- deployments_filtered[1,] |>
select(all_of(col_deploy)) |>
group_split(study_id) |>
map(~{
study_id <- unique(.x$study_id)
individuals <- unique(.x$individual_local_identifier) |>
as.character()
res <- safe_study_download(study_id, c(653, 2299894820), individuals)
if(!is.null(res$result)){
study_file <- here("Data", "Studies", str_c(study_id, "_study.csv"))
tibble(res$result) |>
write_csv(study_name)
tibble(study_id = study_id, file = study_file)
} else {
tibble(study_id = study_id, error_text = paste(res$error, collapse = " "))
}
},
.progess = T
) |>
bind_rows()
View(bla)
library(move2)
library(tidyverse)
library(here)
library(units)
# Things of interest ------------------------------------------------------
# defining species of interest
target_sp <- c("Anas platyrhynchos", "Columba livia",
"Chroicocephalus ridibundus", "Sturnus vulgaris",
"Turdus merula", "Circus aeruginosus", "Accipiter gentilis",
"Passer domesticus")
tags_ids <- c("GPS", "Sigfox Geolocation")
tags_ids_deployments <- c("gps", "sigfox-geolocation")
# defining columns of interest
col_interest <- c("id", "name", "taxon_ids", "sensor_type_ids",
"timestamp_first_deployed_location",
"timestamp_last_deployed_location",
"number_of_individuals", "number_of_tags",
"number_of_deployed_locations",
"i_am_owner", "is_test", "i_have_download_access",
"sensor_type_ids", "contact_person_name", "main_location"
)
deployments <- here("Data", "downloadable_studies_deployments_filtered.csv") |>
read_csv(show_col_type = F)
col_deploy <- c("taxon_canonical_name", "study_id", "deployment_id" ,
"sensor_type_ids",
"individual_local_identifier", "individual_number_of_deployments",
"deployment_local_identifier", "tag_local_identifier",
"sex", "animal_life_stage",  "manipulation_type", "error_text"
)
# Define a custom function to handle multiple arguments
study_download <- function(
study_id, sensor_type_id, individual_local_identifier
) {
movebank_download_study(
study_id,
sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
# remove_movebank_outliers = T,
# omit_derived_data = T,
# convert_spatial_columns = F,
# atributes = NULL
)
}
# Wrap the custom function with safely
safe_study_download <- safely(study_download)
bla <- deployments |>
select(all_of(col_deploy)) |>
group_split(study_id) |>
map(~{
study_id <- unique(.x$study_id)
individuals <- unique(.x$individual_local_identifier) |>
as.character()
res <- safe_study_download(study_id, c(653, 2299894820), individuals)
if(!is.null(res$result)){
study_file <- here("Data", "Studies", str_c(study_id, "_study.csv"))
tibble(res$result) |>
write_csv(study_name)
tibble(study_id = study_id, file = study_file)
} else {
tibble(study_id = study_id, error_text = paste(res$error, collapse = " "))
}
},
.progess = T
) |>
bind_rows()
library(move2)
library(tidyverse)
library(here)
library(units)
deployments <- here("Data", "downloadable_studies_deployments_filtered.csv") |>
read_csv(show_col_type = F)
col_deploy <- c("taxon_canonical_name", "study_id", "deployment_id" ,
"sensor_type_ids",
"individual_local_identifier", "individual_number_of_deployments",
"deployment_local_identifier", "tag_local_identifier",
"sex", "animal_life_stage",  "manipulation_type", "error_text"
)
# Define a custom function to handle multiple arguments
study_download <- function(
study_id, sensor_type_id, individual_local_identifier
) {
movebank_download_study(
study_id,
sensor_type_id = sensor_type_id,
individual_local_identifier = individual_local_identifier,
# remove_movebank_outliers = T,
# omit_derived_data = T,
# convert_spatial_columns = F,
# atributes = NULL
)
}
# Wrap the custom function with safely
safe_study_download <- safely(study_download)
bla <- deployments |>
select(all_of(col_deploy)) |>
group_split(study_id) |>
map(~{
study_id <- unique(.x$study_id)
individuals <- unique(.x$individual_local_identifier) |>
as.character()
res <- safe_study_download(study_id, c(653, 2299894820), individuals)
if(!is.null(res$result)){
study_file <- here("Data", "Studies", str_c(study_id, "_study.csv"))
tibble(res$result) |>
write_csv(study_file)
tibble(study_id = study_id, file = study_file)
} else {
tibble(study_id = study_id, error_text = paste(res$error, collapse = " "))
}
},
.progess = T
) |>
bind_rows()
